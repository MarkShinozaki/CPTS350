# Important Terms and Definitions
### 1. Algorithm:

- **Definition**: A finite set of well-defined instructions or rules that provide a sequence of operations to solve a problem or perform a computation.
  
- **Example**: Sorting a list of numbers using QuickSort.

### 2. Big-O Notation:

- **Definition**: A mathematical notation that describes the upper bound of an algorithm’s time or space complexity in the worst case. It provides an asymptotic analysis of the performance.
  
- **Example**: Merge Sort has a time complexity of O(n log n).

### 3. Dynamic Programming (DP):

- **Definition**: A method for solving problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations.
  
- **Example**: Solving the Fibonacci sequence using memoization.

### 4. Greedy Algorithm:

- **Definition**: An algorithmic paradigm that builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.
  
- **Example**: Huffman coding for data compression.

### 5. Recurrence Relation:

- **Definition**: An equation that recursively defines a sequence; each term is defined as a function of the preceding terms.
  
- **Example**: The relation T(n) = 2T(n/2) + O(n) describes the time complexity of Merge Sort.

### 6. Graph:

- **Definition**: A collection of nodes (or vertices) connected by edges. Graphs can be directed or undirected, weighted or unweighted.
  
- **Example**: A social network where users are nodes, and their friendships are edges.

### 7. NP-Complete:

- **Definition**: A class of problems for which no polynomial-time solution is known, but if one such problem can be solved in polynomial time, all NP problems can be solved in polynomial time.
  
- **Example**: The Traveling Salesman Problem (TSP).

### 8. Divide and Conquer:

- **Definition**: A strategy for solving problems by breaking them down into smaller subproblems, solving each subproblem independently, and then combining their solutions.
  
- **Example**: Karatsuba’s algorithm for fast multiplication.

### 9. Strongly Connected Component (SCC):

- **Definition**: In a directed graph, an SCC is a maximal subgraph where every vertex is reachable from every other vertex within the subgraph.
  
- **Example**: SCCs are used in analyzing the structure of complex networks.

### 10. Heaps:

- **Definition**: A specialized tree-based data structure that satisfies the heap property, where the parent node is always either greater than or equal to (max-heap) or less than or equal to (min-heap) its children.
  
- **Example**: Heaps are used to implement priority queues.

## Key People and Algorithms

### 1. Dijkstra’s Algorithm:

- **Function**: An algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks.

- **Named After**: Edsger Dijkstra, who proposed the algorithm in 1956.

### 2. Karatsuba Algorithm:

- **Functio**n: A divide and conquer algorithm for fast multiplication of large numbers. It is more efficient than the classical algorithm.

- **Named After**: Anatolii Karatsuba, who developed the algorithm in 1960.

### 3. Huffman Coding:

- **Function**: A greedy algorithm used for lossless data compression, where the most frequent characters are assigned the shortest codes.

- **Named After**: David A. Huffman, who developed it in 1952.

### 4. Knuth-Morris-Pratt (KMP) Algorithm:

- **Function**: A linear-time algorithm for string matching that avoids unnecessary re-evaluations.

- **Named After**: Donald Knuth, Vaughan Pratt, and James H. Morris, who jointly published it in 1977.

### 5. Prim’s Algorithm:

- **Function**: An algorithm that finds the minimum spanning tree for a connected, weighted, undirected graph.

- **Named After**: Robert C. Prim, who described it in 1957.

### 6. Tarjan’s Algorithm:

- **Function**: An algorithm used to find all strongly connected components (SCCs) in a directed graph in linear time.

- **Named After**: Robert Tarjan, who introduced it in 1972.

### 7. Strassen’s Algorithm:

- **Function**: An algorithm for matrix multiplication that is faster than the standard algorithm, particularly for large matrices.

- **Named After**: Volker Strassen, who developed it in 1969.

### 8. Ford-Fulkerson Algorithm:

- **Function**: An algorithm for computing the maximum flow in a flow network.

- **Named After**: L. R. Ford, Jr. and D. R. Fulkerson, who proposed it in 1956.

### 9. Cook-Levin Theorem:

- **Function**: A foundational result in computational complexity theory that proves the NP-completeness of the Boolean satisfiability problem (SAT).

- **Named After**: Stephen Cook and Leonid Levin, who independently proved it in the 1970s.

### 10. Bellman-Ford Algorithm:

- **Function**: An algorithm for finding the shortest paths from a single source to all other nodes in a graph, which can handle negative weight edges.

- Named After: Richard Bellman and Lester Ford, who developed it in the 1950s.


